<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"sosquan.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="python装饰器详解前言本文将带你学习装饰器在 Python 中的工作原理，如果在函数和类中使用装饰器，如何利用装饰器避免代码重复（DRY 原则，Don’t Repeat Yourself ）。 装饰器是什么装饰器一直以来都是 Python 中很有用、很经典的一个 feature，在工程中的应用也十分广泛，比如日志、缓存等等的任务都会用到。然而，在平常工作生活中，我发现不少人，尤其是初学者，常常">
<meta property="og:type" content="article">
<meta property="og:title" content="否极泰来">
<meta property="og:url" content="https://sosquan.github.io/2023/12/06/%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%9F/index.html">
<meta property="og:site_name" content="否极泰来">
<meta property="og:description" content="python装饰器详解前言本文将带你学习装饰器在 Python 中的工作原理，如果在函数和类中使用装饰器，如何利用装饰器避免代码重复（DRY 原则，Don’t Repeat Yourself ）。 装饰器是什么装饰器一直以来都是 Python 中很有用、很经典的一个 feature，在工程中的应用也十分广泛，比如日志、缓存等等的任务都会用到。然而，在平常工作生活中，我发现不少人，尤其是初学者，常常">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-12-06T02:20:22.117Z">
<meta property="article:modified_time" content="2023-11-08T02:35:17.631Z">
<meta property="article:author" content="What">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://sosquan.github.io/2023/12/06/%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%9F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sosquan.github.io/2023/12/06/%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%9F/","path":"2023/12/06/如何写博客？/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | 否极泰来</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">否极泰来</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.</span> <span class="nav-text">python装饰器详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">2.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.</span> <span class="nav-text">装饰器是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="nav-number">4.</span> <span class="nav-text">装饰器语法糖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">函数装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">装饰不带参数的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%B8%A6%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">装饰带一个参数的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%B8%A6%E4%B8%8D%E5%AE%9A%E9%95%BF%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">装饰带不定长参数的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E5%B8%A6%E5%8F%82%E6%95%B0"><span class="nav-number">5.4.</span> <span class="nav-text">装饰器带参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E5%8E%9F%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="nav-number">5.5.</span> <span class="nav-text">原函数还是原函数吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">类装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%9C%AC%E8%BA%AB%E6%97%A0%E5%8F%82%E6%95%B0"><span class="nav-number">6.1.</span> <span class="nav-text">类装饰器-本身无参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">6.2.</span> <span class="nav-text">如何定义带参数的类装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">6.3.</span> <span class="nav-text">描述符与装饰器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">装饰类的装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E8%A3%85%E9%A5%B0%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">7.1.</span> <span class="nav-text">如何定义装饰类的装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A7%E7%94%A8functools-partial"><span class="nav-number">7.2.</span> <span class="nav-text">巧用functools.partial</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#django%E7%A4%BA%E4%BE%8B"><span class="nav-number">7.3.</span> <span class="nav-text">django示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objprint%E7%A4%BA%E4%BE%8B"><span class="nav-number">7.4.</span> <span class="nav-text">objprint示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-wrapt-%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99%E6%9B%B4%E6%89%81%E5%B9%B3%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">使用 wrapt 模块编写更扁平的装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8wrapt%E5%86%99%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">8.1.</span> <span class="nav-text">使用wrapt写一个不带参数的装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8wrapt%E5%86%99%E4%B8%80%E4%B8%AA%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">8.2.</span> <span class="nav-text">使用wrapt写一个带参数的装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8wrapt%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%B5%8C%E5%A5%97"><span class="nav-number">8.3.</span> <span class="nav-text">使用wrapt的装饰器嵌套</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="nav-number">9.</span> <span class="nav-text">装饰器的嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">10.</span> <span class="nav-text">多装饰器的执行顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90"><span class="nav-number">10.1.</span> <span class="nav-text">举个栗子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B"><span class="nav-number">11.</span> <span class="nav-text">装饰器应用场景示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">11.1.</span> <span class="nav-text">缓存装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%90%88%E6%B3%95%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="nav-number">11.2.</span> <span class="nav-text">输入合法性检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="nav-number">11.3.</span> <span class="nav-text">日志记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="nav-number">11.4.</span> <span class="nav-text">身份认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.5.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.6.</span> <span class="nav-text">策略模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">12.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">What</p>
  <div class="site-description" itemprop="description">当做记录自己学习过程的小空间</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sosquan.github.io/2023/12/06/%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="What">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="否极泰来">
      <meta itemprop="description" content="当做记录自己学习过程的小空间">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 否极泰来">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-06 10:20:22" itemprop="dateCreated datePublished" datetime="2023-12-06T10:20:22+08:00">2023-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 10:35:17" itemprop="dateModified" datetime="2023-11-08T10:35:17+08:00">2023-11-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="python装饰器详解"><a href="#python装饰器详解" class="headerlink" title="python装饰器详解"></a>python装饰器详解</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>本文将带你学习装饰器在 Python 中的工作原理，如果在函数和类中使用装饰器，如何利用装饰器避免代码重复（<code>DRY 原则，Don’t Repeat Yourself</code> ）。</p>
<h2 id="装饰器是什么"><a href="#装饰器是什么" class="headerlink" title="装饰器是什么"></a><strong>装饰器是什么</strong></h2><p>装饰器一直以来都是 Python 中很有用、很经典的一个 feature，在工程中的应用也十分广泛，比如日志、缓存等等的任务都会用到。然而，在平常工作生活中，我发现不少人，尤其是初学者，常常因为其相对复杂的表示，对装饰器望而生畏，认为它“<code>too fancy to learn</code>”，实际并不如此。</p>
<p>你可能已经和装饰器打过不少交道了。在做面向对象编程时，我们就经常会用到 <code>@staticmethod</code> 和 <code>@classmethod</code> 两个内置装饰器。此外，如果你接触过 <a href="https://link.zhihu.com/?target=https://click.palletsprojects.com/en/7.x/">click</a> 模块，就更不会对装饰器感到陌生。click 最为人所称道的参数定义接口 <code>@click.option(...)</code> 就是利用装饰器实现的。</p>
<p>装饰器在 Python中是一个非常强大和有用的工具，因为它允许程序员修改函数或类的行为。装饰器允许我们包装另一个函数，<code>以扩展包装函数的行为</code>，而无需修改基础函数定义。这也被称为元编程，因为程序本身在程序运行时会尝试修改自身的另一部分。</p>
<p>装饰器是<code>语法糖</code>： 在代码中利用更简洁流畅的语法实现更为复杂的功能。</p>
<blockquote>
<p>❝ 万能公式：注意理解语法糖的等价形式<br>❞</p>
</blockquote>
<p>我们知道，Python中一切皆对象。这意味着<code>Python中的函数可以用作参数或作为参数传递</code>。一等函数的属性：</p>
<ul>
<li>函数是 Object 类型的实例。</li>
<li>可以将函数存储在变量中。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def func(message):</span><br><span class="line">    print(&#x27;Got a message: &#123;&#125;&#x27;.format(message))</span><br><span class="line">    </span><br><span class="line">send_message = func</span><br><span class="line">send_message(&#x27;hello world&#x27;)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">Got a message: hello world</span><br></pre></td></tr></table></figure>

<ul>
<li>可以将该函数作为参数传递给另一个函数。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def get_message(message):</span><br><span class="line">    return &#x27;Got a message: &#x27; + message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def root_call(func, message):</span><br><span class="line">    print(func(message))</span><br><span class="line">    </span><br><span class="line">root_call(get_message, &#x27;hello world&#x27;)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">Got a message: hello world</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以在函数里定义函数，也就是函数的嵌套。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def func(message):</span><br><span class="line">    def get_message(message):</span><br><span class="line">        print(&#x27;Got a message: &#123;&#125;&#x27;.format(message))</span><br><span class="line">    return get_message(message)</span><br><span class="line"></span><br><span class="line">func(&#x27;hello world&#x27;)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">Got a message: hello world</span><br></pre></td></tr></table></figure>

<ul>
<li>函数的返回值也可以是函数对象（闭包）。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def func_closure():</span><br><span class="line">    def get_message(message):</span><br><span class="line">        print(&#x27;Got a message: &#123;&#125;&#x27;.format(message))</span><br><span class="line">    return get_message</span><br><span class="line"></span><br><span class="line">send_message = func_closure()</span><br><span class="line">send_message(&#x27;hello world&#x27;)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">Got a message: hello world</span><br></pre></td></tr></table></figure>

<ul>
<li>可以将它们存储在数据结构中，例如哈希表，列表等。</li>
</ul>
<h2 id="装饰器语法糖"><a href="#装饰器语法糖" class="headerlink" title="装饰器语法糖"></a><strong>装饰器语法糖</strong></h2><p>如果你接触<code>Python</code>有一段时间了的话，想必你对<code>@</code>符号一定不陌生了，没错<code>@</code>符号就是装饰器的语法糖。它放在一个函数开始定义的地方，它就像一顶帽子一样戴在这个函数的头上。和这个函数绑定在一起。在我们调用这个函数的时候，第一件事并不是执行这个函数，而是将这个函数做为参数传入它头顶上这顶帽子，这顶帽子我们称之为<code>装饰函数</code>或<code>装饰器</code>。</p>
<p>装饰器的使用方法很固定：</p>
<ul>
<li>先定义一个装饰函数（帽子）（也可以用类、偏函数实现）</li>
<li>再定义你的业务函数、或者类（人）</li>
<li>最后把这顶帽子戴在这个人头上</li>
</ul>
<h2 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a><strong>函数装饰器</strong></h2><p><code>decorator必须是一个“可被调用（callable）的对象或属性描述符（Descriptors）</code>。</p>
<p>理解描述符是深入理解 Python 的关键，因为它们是许多功能的基础，包括函数、方法、属性、类方法、静态方法和对超类的引用。这个暂不做过多赘述！</p>
<blockquote>
<p>❝ <code>输入是函数，输出也是函数~</code><br>❞</p>
</blockquote>
<h3 id="装饰不带参数的函数"><a href="#装饰不带参数的函数" class="headerlink" title="装饰不带参数的函数"></a><strong>装饰不带参数的函数</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def my_decorator(func):</span><br><span class="line">    def wrapper():</span><br><span class="line">        print(&#x27;wrapper of decorator&#x27;)</span><br><span class="line">        func()</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">def greet():</span><br><span class="line">    print(&#x27;hello world&#x27;)</span><br><span class="line"></span><br><span class="line"># 这里可以用下面的@语法糖实现，更优雅</span><br><span class="line">greet = my_decorator(greet)</span><br><span class="line">greet()</span><br></pre></td></tr></table></figure>

<p>更优雅的语法糖<code>@</code>表示，大大提高函数的重复利用和程序的可读性：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def my_decorator(func):</span><br><span class="line">    def wrapper():</span><br><span class="line">        print(&#x27;wrapper of decorator&#x27;)</span><br><span class="line">        func()</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@my_decorator</span><br><span class="line">def greet():</span><br><span class="line">    print(&#x27;hello world&#x27;)</span><br><span class="line"></span><br><span class="line">greet()</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 输出</span><br><span class="line">wrapper of decorator</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h3 id="装饰带一个参数的函数"><a href="#装饰带一个参数的函数" class="headerlink" title="装饰带一个参数的函数"></a><strong>装饰带一个参数的函数</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def my_decorator(func):</span><br><span class="line">    def wrapper(message):</span><br><span class="line">        print(&#x27;wrapper of decorator&#x27;)</span><br><span class="line">        func(message)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@my_decorator</span><br><span class="line">def greet(message):</span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">greet(&#x27;hello world&#x27;)</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def my_decorator(func):</span><br><span class="line">    def wrapper(message):</span><br><span class="line">        print(&#x27;wrapper of decorator&#x27;)</span><br><span class="line">        func(message)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def greet(message):</span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line"># @语法糖等价于下面这个</span><br><span class="line">greet = my_decorator(greet)</span><br><span class="line">greet(&#x27;hello world&#x27;)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 输出</span><br><span class="line">wrapper of decorator</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h3 id="装饰带不定长参数的函数"><a href="#装饰带不定长参数的函数" class="headerlink" title="装饰带不定长参数的函数"></a><strong>装饰带不定长参数的函数</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def my_decorator(func):</span><br><span class="line">    def wrapper(message, *args, **kwargs):  # 不定长参数*args,**kwargs</span><br><span class="line">        print(&#x27;wrapper of decorator&#x27;)</span><br><span class="line">        func(message, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@my_decorator</span><br><span class="line">def greet(message):</span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">greet(&#x27;hello world&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@my_decorator</span><br><span class="line">def greet2(message, num=2):</span><br><span class="line">    print(message, num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">greet2(&quot;hello world2&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="装饰器带参数"><a href="#装饰器带参数" class="headerlink" title="装饰器带参数"></a><strong>装饰器带参数</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def repeat(num):</span><br><span class="line">    def my_decorator(func):</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            for i in range(num):</span><br><span class="line">                print(&#x27;wrapper of decorator&#x27;)</span><br><span class="line">                func(*args, **kwargs)</span><br><span class="line">        return wrapper</span><br><span class="line">    return my_decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@repeat(4)</span><br><span class="line">def greet(message):</span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line"># @语法糖等价于：</span><br><span class="line"># my_decorator = repeat(4)</span><br><span class="line"># greet = my_decorator(greet)</span><br><span class="line"></span><br><span class="line">greet(&#x27;hello world&#x27;)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 输出：</span><br><span class="line">wrapper of decorator</span><br><span class="line">hello world</span><br><span class="line">wrapper of decorator</span><br><span class="line">hello world</span><br><span class="line">wrapper of decorator</span><br><span class="line">hello world</span><br><span class="line">wrapper of decorator</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h3 id="原函数还是原函数吗？"><a href="#原函数还是原函数吗？" class="headerlink" title="原函数还是原函数吗？"></a><strong>原函数还是原函数吗？</strong></h3><p>我们试着打印出 greet() 函数的一些元信息：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">greet.__name__</span><br><span class="line">## 输出</span><br><span class="line">&#x27;wrapper&#x27;</span><br><span class="line"></span><br><span class="line">help(greet)</span><br><span class="line"># 输出</span><br><span class="line">Help on function wrapper in module __main__:</span><br><span class="line"></span><br><span class="line">wrapper(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，我们通常使用内置的装饰器<code>@functools.wrap</code>，它会帮助保留原函数的元信息（也就是将原函数的元信息，拷贝到对应的装饰器函数里）。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def my_decorator(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        print(&#x27;wrapper of decorator&#x27;)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    return wrapper</span><br><span class="line">    </span><br><span class="line">@my_decorator</span><br><span class="line">def greet(message):</span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line">greet.__name__</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">&#x27;greet&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a><strong>类装饰器</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义一个类装饰器，装饰函数，默认调用__call__方法</span><br></pre></td></tr></table></figure>

<h3 id="类装饰器-本身无参数"><a href="#类装饰器-本身无参数" class="headerlink" title="类装饰器-本身无参数"></a><strong>类装饰器-本身无参数</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Count:</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.num_calls = 0</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        self.num_calls += 1</span><br><span class="line">        print(&#x27;num of calls is: &#123;&#125;&#x27;.format(self.num_calls))</span><br><span class="line">        return self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">@Count</span><br><span class="line">def example():</span><br><span class="line">    print(&quot;hello world&quot;)</span><br><span class="line"></span><br><span class="line"># 等价于example = Count(example) </span><br><span class="line"></span><br><span class="line">example()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>❝ 类装饰器本身无参数时等价于<code>example = Count(example)</code><br>❞</p>
</blockquote>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 输出</span><br><span class="line">num of calls is: 1</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">example()</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">num of calls is: 2</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h3 id="如何定义带参数的类装饰器"><a href="#如何定义带参数的类装饰器" class="headerlink" title="如何定义带参数的类装饰器"></a><strong>如何定义带参数的类装饰器</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Count:</span><br><span class="line">    def __init__(self, a, *args, **kwargs): # 类装饰器参数</span><br><span class="line">        self.a = a</span><br><span class="line">        self.num_calls = 0</span><br><span class="line"></span><br><span class="line">    def __call__(self, func): # 被装饰函数</span><br><span class="line">        print(self.a)</span><br><span class="line"></span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            print(self.a)</span><br><span class="line">            self.num_calls += 1</span><br><span class="line">            print(&#x27;num of calls is: &#123;&#125;&#x27;.format(self.num_calls))</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line">        return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Count(&quot;aaaa&quot;)</span><br><span class="line">def example():</span><br><span class="line">    print(&quot;hello world&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;开始调用example函数..............&quot;)</span><br><span class="line"></span><br><span class="line">example()</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Count:</span><br><span class="line">    def __init__(self, a, *args, **kwargs):</span><br><span class="line">        self.a = a</span><br><span class="line">        self.num_calls = 0</span><br><span class="line"></span><br><span class="line">    def __call__(self, func):</span><br><span class="line">        print(self.a)</span><br><span class="line"></span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            print(self.a)</span><br><span class="line">            self.num_calls += 1</span><br><span class="line">            print(&#x27;num of calls is: &#123;&#125;&#x27;.format(self.num_calls))</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line">        return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def example():</span><br><span class="line">    print(&quot;hello world&quot;)</span><br><span class="line"></span><br><span class="line"># @语法糖等价形式</span><br><span class="line">example = Count(&quot;aaaa&quot;)(example)</span><br><span class="line"></span><br><span class="line">print(&quot;开始调用example函数..............&quot;)</span><br><span class="line"></span><br><span class="line">example()</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aaaa</span><br><span class="line">开始调用example函数..............</span><br><span class="line">aaaa</span><br><span class="line">num of calls is: 1</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h3 id="描述符与装饰器"><a href="#描述符与装饰器" class="headerlink" title="描述符与装饰器"></a><strong>描述符与装饰器</strong></h3><p>还有一类装饰器比较特殊，比如python描述符类的<code>property</code>。</p>
<blockquote>
<p>❝ 在Python中，属性描述符可以用作装饰器，是因为描述符对象可以通过实现 <code>__get__()</code>、<code>__set__()</code> 和 <code>__delete__()</code> 方法来拦截对属性的访问和操作。 <a href="https://link.zhihu.com/?target=https://docs.python.org/3/reference/datamodel.html%23descriptors">https://docs.python.org/3/reference/datamodel.html#descriptors</a><br><a href="https://link.zhihu.com/?target=https://docs.python.org/3/howto/descriptor.html%23descriptorhowto">https://docs.python.org/3/howto/descriptor.html#descriptorhowto</a><br>❞</p>
</blockquote>
<p><code>关于描述符，这里不赘述</code>。基于描述符，我们也可以实现自定义的property:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class cached_property:</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.name = func.__name__</span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        if instance is None:</span><br><span class="line">            return self</span><br><span class="line">        if self.name not in self.cache:</span><br><span class="line">            value = self.func(instance)</span><br><span class="line">            self.cache[self.name] = value</span><br><span class="line">        return self.cache[self.name]</span><br><span class="line"></span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">        raise TypeError(&quot;can&#x27;t set attribute&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyClass:</span><br><span class="line">    @cached_property</span><br><span class="line">    # @property</span><br><span class="line">    def value(self):</span><br><span class="line">        print(&quot;Calculating value...&quot;)</span><br><span class="line">        return 42</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">print(obj.value)  # 输出: Calculating value...   42</span><br><span class="line"></span><br><span class="line"># 使用缓存的值</span><br><span class="line">print(obj.value)  # 输出: 42</span><br><span class="line"></span><br><span class="line"># 尝试修改属性值（抛出TypeError）</span><br><span class="line">obj.value = &quot;invalid&quot;  # 抛出 TypeError: can&#x27;t set attribute</span><br></pre></td></tr></table></figure>

<h2 id="装饰类的装饰器"><a href="#装饰类的装饰器" class="headerlink" title="装饰类的装饰器"></a><strong>装饰类的装饰器</strong></h2><p>在Python中，装饰类的装饰器是一种特殊类型的函数，它用于修改或增强类的行为。装饰器可以在不修改原始类定义的情况下，通过将类传递给装饰器函数来对其进行装饰。</p>
<p>通常情况下，装饰类的装饰器是一个接受类作为参数的函数，并返回一个新的类或修改原始类的函数。这个装饰器函数可以在类定义之前使用<code>@</code>符号应用到类上。</p>
<blockquote>
<p>❝ <code>输入是类，输出也是类~</code><br>❞</p>
</blockquote>
<h3 id="如何定义装饰类的装饰器"><a href="#如何定义装饰类的装饰器" class="headerlink" title="如何定义装饰类的装饰器"></a><strong>如何定义装饰类的装饰器</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def timer_decorator(cls):</span><br><span class="line">    class TimerClass(cls):</span><br><span class="line">        def __getattribute__(self, name):</span><br><span class="line">            attribute = object.__getattribute__(self, name)</span><br><span class="line"></span><br><span class="line">            if callable(attribute):  # Check if the attribute is a callable (e.g., a method)</span><br><span class="line">                def wrapped_method(*args, **kwargs):</span><br><span class="line">                    start_time = time.time()</span><br><span class="line">                    result = attribute(*args, **kwargs)</span><br><span class="line">                    end_time = time.time()</span><br><span class="line">                    execution_time = end_time - start_time</span><br><span class="line">                    print(f&quot;Method &#x27;&#123;name&#125;&#x27; executed in &#123;execution_time&#125; seconds.&quot;)</span><br><span class="line">                    return result</span><br><span class="line"></span><br><span class="line">                return wrapped_method</span><br><span class="line">            else:</span><br><span class="line">                return attribute</span><br><span class="line"></span><br><span class="line">    return TimerClass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@timer_decorator</span><br><span class="line">class MyClass:</span><br><span class="line">    def my_method(self):</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&quot;Executing my_method&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">obj.my_method()</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executing my_method</span><br><span class="line">Method &#x27;my_method&#x27; executed in 2.0056345462799072 seconds.</span><br></pre></td></tr></table></figure>

<p>上述示例中，<code>timer_decorator</code>装饰器接收一个类作为参数，并返回一个继承自原始类的新类<code>TimerClass</code>。<code>TimerClass</code>中重写了<code>__getattribute__</code>方法，在调用类的方法时，会计算方法的执行时间并进行打印。</p>
<h3 id="巧用functools-partial"><a href="#巧用functools-partial" class="headerlink" title="巧用functools.partial"></a><strong>巧用functools.partial</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import functools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DelayFunc:</span><br><span class="line">    def __init__(self,  duration, func):</span><br><span class="line">        self.duration = duration</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(f&#x27;Wait for &#123;self.duration&#125; seconds...&#x27;)</span><br><span class="line">        time.sleep(self.duration)</span><br><span class="line">        return self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def eager_call(self, *args, **kwargs):</span><br><span class="line">        print(&#x27;Call without delay&#x27;)</span><br><span class="line">        return self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def delay(duration):</span><br><span class="line">    &quot;&quot;&quot;装饰器：推迟某个函数的执行。同时提供 .eager_call 方法立即执行</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 此处为了避免定义额外函数，直接使用 functools.partial 帮助构造</span><br><span class="line">    # DelayFunc 实例</span><br><span class="line">    return functools.partial(DelayFunc, duration)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@delay(duration=2)</span><br><span class="line">def add(a, b):</span><br><span class="line">    return a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这次调用将会延迟 2 秒</span><br><span class="line">add(1, 2)</span><br><span class="line"># 这次调用将会立即执行</span><br><span class="line">add.eager_call(1, 2)</span><br></pre></td></tr></table></figure>

<h3 id="django示例"><a href="#django示例" class="headerlink" title="django示例"></a><strong>django示例</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.auth.decorators import login_required</span><br><span class="line"></span><br><span class="line">def require_login(view_class):</span><br><span class="line">    # 使用@login_required装饰器对dispatch方法进行装饰</span><br><span class="line">    view_class.dispatch = login_required(view_class.dispatch)</span><br><span class="line">    return view_class</span><br><span class="line"></span><br><span class="line">@require_login</span><br><span class="line">class MyView(View):</span><br><span class="line">    def get(self, request):</span><br><span class="line">        # 处理GET请求的逻辑</span><br><span class="line">        return HttpResponse(&quot;GET request&quot;)</span><br><span class="line"></span><br><span class="line">    def post(self, request):</span><br><span class="line">        # 处理POST请求的逻辑</span><br><span class="line">        return HttpResponse(&quot;POST request&quot;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>❝ 等价于<code>MyView = require_login（MyView）</code><br>❞</p>
</blockquote>
<h3 id="objprint示例"><a href="#objprint示例" class="headerlink" title="objprint示例"></a><strong>objprint示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">一个有意思的python三方模块，使用装饰器打印object</span><br><span class="line">from objprint import add_objprint</span><br><span class="line"></span><br><span class="line">class Position:</span><br><span class="line">    def __init__(self, x, y):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">@add_objprint</span><br><span class="line">class Player:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &quot;Alice&quot;</span><br><span class="line">        self.age = 18</span><br><span class="line">        self.items = [&quot;axe&quot;, &quot;armor&quot;]</span><br><span class="line">        self.coins = &#123;&quot;gold&quot;: 1, &quot;silver&quot;: 33, &quot;bronze&quot;: 57&#125;</span><br><span class="line">        self.position = Position(3, 5)</span><br><span class="line"></span><br><span class="line"># This will print the same thing as above</span><br><span class="line">print(Player()) </span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Player</span><br><span class="line">  .name = &#x27;Alice&#x27;,</span><br><span class="line">  .age = 18,</span><br><span class="line">  .items = [&#x27;axe&#x27;, &#x27;armor&#x27;],</span><br><span class="line">  .coins = &#123;&#x27;gold&#x27;: 1, &#x27;silver&#x27;: 33, &#x27;bronze&#x27;: 57&#125;,</span><br><span class="line">  .position = &lt;Position</span><br><span class="line">    .x = 3,</span><br><span class="line">    .y = 5</span><br><span class="line">  &gt;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<h2 id="使用-wrapt-模块编写更扁平的装饰器"><a href="#使用-wrapt-模块编写更扁平的装饰器" class="headerlink" title="使用 wrapt 模块编写更扁平的装饰器"></a><strong>使用 wrapt 模块编写更扁平的装饰器</strong></h2><p>在写装饰器的过程中，你有没有碰到过什么不爽的事情？这里列举两个可能使你特别难受的点：</p>
<blockquote>
<p>❝</p>
</blockquote>
<ol>
<li><code>实现带参数的装饰器时，层层嵌套的函数代码特别难写、难读</code></li>
<li><code>因为函数和类方法的不同，为前者写的装饰器经常没法直接套用在后者上</code></li>
</ol>
<p>❞</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def provide_number(min_num, max_num):</span><br><span class="line">    &quot;&quot;&quot;装饰器：随机生成一个在 [min_num, max_num] 范围的整数，追加为函数的第一个位置参数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def wrapper(func):</span><br><span class="line">        def decorated(*args, **kwargs):</span><br><span class="line">            num = random.randint(min_num, max_num)</span><br><span class="line">            # 将 num 作为第一个参数追加后调用函数</span><br><span class="line">            return func(num, *args, **kwargs)</span><br><span class="line">        return decorated</span><br><span class="line">    return wrapper</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@provide_number(1, 100)</span><br><span class="line">def print_random_number(num):</span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"># 输出 1-100 的随机整数</span><br><span class="line"># OUTPUT: 72</span><br><span class="line">print_random_number()</span><br></pre></td></tr></table></figure>

<p><code>@provide_number</code> 装饰器功能看上去很不错，但它有着我在前面提到的两个问题：<code>嵌套层级深、无法在类方法上使用</code>。如果直接用它去装饰类方法，会出现下面的情况：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    @provide_number(1, 100)</span><br><span class="line">    def print_random_number(self, num):</span><br><span class="line">        print(num)</span><br><span class="line"></span><br><span class="line"># OUTPUT: &lt;__main__.Foo object at 0x104047278&gt;</span><br><span class="line">Foo().print_random_number()</span><br></pre></td></tr></table></figure>

<p><code>Foo</code> 类实例中的 <code>print_random_number</code> 方法将会输出类实例 <code>self</code> ，而不是我们期望的随机数 <code>num</code>。</p>
<p>之所以会出现这个结果，是因为类方法 <em>（method）</em> 和函数 <em>（function）</em> 二者在工作机制上有着细微不同。如果要修复这个问题，<code>provider_number</code> 装饰器在修改类方法的位置参数时，必须聪明的跳过藏在 <code>*args</code> 里面的类实例 <code>self</code> 变量，才能正确的将 <code>num</code> 作为第一个参数注入。</p>
<p>这时，就应该是 <a href="https://link.zhihu.com/?target=https://pypi.org/project/wrapt/">wrapt</a> 模块闪亮登场的时候了。<code>wrapt</code> 模块是一个专门帮助你编写装饰器的工具库。利用它，我们可以非常方便的改造 <code>provide_number</code> 装饰器，完美解决“<code>嵌套层级深</code>”和“<code>无法通用</code>”两个问题，</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">import wrapt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def provide_number(min_num, max_num):</span><br><span class="line">    @wrapt.decorator</span><br><span class="line">    def wrapper(wrapped, instance, args, kwargs):</span><br><span class="line">        # 参数含义：</span><br><span class="line">        #</span><br><span class="line">        # - wrapped：被装饰的函数或类方法</span><br><span class="line">        # - instance：</span><br><span class="line">        #   - 如果被装饰者为普通类方法，该值为类实例</span><br><span class="line">        #   - 如果被装饰者为 classmethod 类方法，该值为类</span><br><span class="line">        #   - 如果被装饰者为类/函数/静态方法，该值为 None</span><br><span class="line">        #</span><br><span class="line">        # - args：调用时的位置参数（注意没有 * 符号）</span><br><span class="line">        # - kwargs：调用时的关键字参数（注意没有 ** 符号）</span><br><span class="line">        #</span><br><span class="line">        num = random.randint(min_num, max_num)</span><br><span class="line">        # 无需关注 wrapped 是类方法或普通函数，直接在头部追加参数</span><br><span class="line">        args = (num,) + args</span><br><span class="line">        return wrapped(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@provide_number(1, 100)</span><br><span class="line">def print_random_number(num):</span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    @provide_number(1, 100)</span><br><span class="line">    def print_random_number(self, num):</span><br><span class="line">        print(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输出 1-100 的随机整数</span><br><span class="line">print_random_number()</span><br><span class="line"></span><br><span class="line">Foo().print_random_number()</span><br></pre></td></tr></table></figure>

<h3 id="使用wrapt写一个不带参数的装饰器"><a href="#使用wrapt写一个不带参数的装饰器" class="headerlink" title="使用wrapt写一个不带参数的装饰器"></a><strong>使用wrapt写一个不带参数的装饰器</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import wrapt</span><br><span class="line"></span><br><span class="line">@wrapt.decorator</span><br><span class="line">def pass_through(wrapped, instance, args, kwargs):</span><br><span class="line">    return wrapped(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">@pass_through</span><br><span class="line">def function():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<h3 id="使用wrapt写一个带参数的装饰器"><a href="#使用wrapt写一个带参数的装饰器" class="headerlink" title="使用wrapt写一个带参数的装饰器"></a><strong>使用wrapt写一个带参数的装饰器</strong></h3><p>如果您希望实现一个接受参数的装饰器，请将装饰器的定义包装在函数闭包中。应用装饰器时提供给外部函数的任何参数都将在调用包装函数时可供内部包装器使用。</p>
<blockquote>
<p>❝ 函数签名是固定的，必须是<code>(wrapped, instance, args, kwargs)</code><br>❞</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import wrapt</span><br><span class="line"></span><br><span class="line">def with_arguments(myarg1, myarg2):</span><br><span class="line">    @wrapt.decorator</span><br><span class="line">    def wrapper(wrapped, instance, args, kwargs):</span><br><span class="line">        return wrapped(*args, **kwargs)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@with_arguments(1, 2)</span><br><span class="line">def function():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<h3 id="使用wrapt的装饰器嵌套"><a href="#使用wrapt的装饰器嵌套" class="headerlink" title="使用wrapt的装饰器嵌套"></a><strong>使用wrapt的装饰器嵌套</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import wrapt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@wrapt.decorator</span><br><span class="line">def uppercase(wrapped, instance, args, kwargs):</span><br><span class="line">    result = wrapped(*args, **kwargs)</span><br><span class="line">    if isinstance(result, str):</span><br><span class="line">        return result.upper()</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def repeat(n):</span><br><span class="line">    @wrapt.decorator</span><br><span class="line">    def wrapper(wrapped, instance, args, kwargs):</span><br><span class="line">        return [wrapped(*args, **kwargs) for _ in range(n)]</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@repeat(3)</span><br><span class="line">@uppercase</span><br><span class="line">def greet(name):</span><br><span class="line">    return f&quot;Hello, &#123;name&#125;!&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(greet(&quot;Alice&quot;))  # Output: [&#x27;HELLO, ALICE!&#x27;, &#x27;HELLO, ALICE!&#x27;, &#x27;HELLO, ALICE!&#x27;]</span><br></pre></td></tr></table></figure>

<p>使用 <code>wrapt</code> 模块编写的装饰器，相比原来拥有下面这些优势：</p>
<ul>
<li>嵌套层级少：使用 <code>@wrapt.decorator</code> 可以将两层嵌套减少为一层</li>
<li>更简单：处理位置与关键字参数时，可以忽略类实例等特殊情况</li>
<li>更灵活：针对 <code>instance</code> 值进行条件判断后，更容易让装饰器变得通用</li>
</ul>
<h2 id="装饰器的嵌套"><a href="#装饰器的嵌套" class="headerlink" title="装饰器的嵌套"></a><strong>装饰器的嵌套</strong></h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def my_decorator1(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        print(&#x27;execute decorator1&#x27;)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def my_decorator2(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        print(&#x27;execute decorator2&#x27;)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@my_decorator1</span><br><span class="line">@my_decorator2</span><br><span class="line">def greet(message):</span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">greet(&#x27;hello world&#x27;)</span><br></pre></td></tr></table></figure>

<p>它的执行顺序从里到外，所以上面的语句也等效于下面这行代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greet = my_decorator1(my_decorator2(greet))</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line"># greet = my_decorator2(greet)</span><br><span class="line"># greet = my_decorator1(greet)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 输出</span><br><span class="line">execute decorator1</span><br><span class="line">execute decorator2</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h2 id="多装饰器的执行顺序"><a href="#多装饰器的执行顺序" class="headerlink" title="多装饰器的执行顺序"></a><strong>多装饰器的执行顺序</strong></h2><p>说到Python装饰器的执行顺序，有很多半吊子张口就来：</p>
<blockquote>
<p>❝ 靠近函数名的装饰器先执行，远离函数名的装饰器后执行。<br>❞</p>
</blockquote>
<p><code>这种说法是不准确的</code>。</p>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a><strong>举个栗子</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def decorator_outer(func):</span><br><span class="line">    print(&quot;我是外层装饰器&quot;)</span><br><span class="line">    print(&#x27;a&#x27;)</span><br><span class="line">    print(&#x27;b&#x27;)</span><br><span class="line">    def wrapper():</span><br><span class="line">        print(&#x27;外层装饰器，函数运行之前&#x27;)</span><br><span class="line">        func()</span><br><span class="line">        print(&#x27;外层装饰器，函数运行之后&#x27;)</span><br><span class="line">    print(&#x27;外层装饰器闭包初始化完毕&#x27;)</span><br><span class="line">    print(&#x27;c&#x27;)</span><br><span class="line">    print(&#x27;d&#x27;)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">def decorator_inner(func):</span><br><span class="line">    print(&quot;我是内层装饰器&quot;)</span><br><span class="line">    print(1)</span><br><span class="line">    print(2)</span><br><span class="line">    def wrapper():</span><br><span class="line">        print(&#x27;内层装饰器，函数运行之前&#x27;)</span><br><span class="line">        func()</span><br><span class="line">        print(&#x27;内层装饰器，函数运行之后&#x27;)</span><br><span class="line">    print(&#x27;内层装饰器闭包初始化完毕&#x27;)</span><br><span class="line">    print(3)</span><br><span class="line">    print(4)</span><br><span class="line">    return wrapper  </span><br><span class="line"></span><br><span class="line">@decorator_outer</span><br><span class="line">@decorator_inner</span><br><span class="line">def func():</span><br><span class="line">    print(&quot;我是函数本身&quot;)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>在这里，你可以先花几秒钟思考下这段代码的输出结果是什么呢？也许会出乎一些人的预料！！</p>
<p><code>结果揭晓</code>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">我是内层装饰器</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">内层装饰器闭包初始化完毕</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">我是外层装饰器</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">外层装饰器闭包初始化完毕</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line"># ==================================================</span><br><span class="line">外层装饰器，函数运行之前</span><br><span class="line">内层装饰器，函数运行之前</span><br><span class="line">我是函数本身</span><br><span class="line">内层装饰器，函数运行之后</span><br><span class="line">外层装饰器，函数运行之后</span><br></pre></td></tr></table></figure>

<p>其实，只要我们套用万能替代公式，是不难得出正确的答案的。直接上代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">def decorator_outer(func):</span><br><span class="line">    print(&quot;我是外层装饰器&quot;)</span><br><span class="line">    print(&#x27;a&#x27;)</span><br><span class="line">    print(&#x27;b&#x27;)</span><br><span class="line"></span><br><span class="line">    def wrapper():</span><br><span class="line">        print(&#x27;外层装饰器，函数运行之前&#x27;)</span><br><span class="line">        func()</span><br><span class="line">        print(&#x27;外层装饰器，函数运行之后&#x27;)</span><br><span class="line"></span><br><span class="line">    print(&#x27;外层装饰器闭包初始化完毕&#x27;)</span><br><span class="line">    print(&#x27;c&#x27;)</span><br><span class="line">    print(&#x27;d&#x27;)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def decorator_inner(func):</span><br><span class="line">    print(&quot;我是内层装饰器&quot;)</span><br><span class="line">    print(1)</span><br><span class="line">    print(2)</span><br><span class="line"></span><br><span class="line">    def wrapper():</span><br><span class="line">        print(&#x27;内层装饰器，函数运行之前&#x27;)</span><br><span class="line">        func()</span><br><span class="line">        print(&#x27;内层装饰器，函数运行之后&#x27;)</span><br><span class="line"></span><br><span class="line">    print(&#x27;内层装饰器闭包初始化完毕&#x27;)</span><br><span class="line">    print(3)</span><br><span class="line">    print(4)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># @decorator_outer</span><br><span class="line"># @decorator_inner</span><br><span class="line">def func():</span><br><span class="line">    print(&quot;我是函数本身&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># func()</span><br><span class="line"></span><br><span class="line">func = decorator_inner(func)</span><br><span class="line">print(&quot;----------------------------------------&quot;)</span><br><span class="line">func = decorator_outer(func)</span><br><span class="line">print(&quot;==================================================&quot;)</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>❝ 装饰器里面的代码中，<code>wrapper</code>闭包外面的代码确实是内层装饰器先执行，外层装饰器后执行。这部分是在带上<code>@</code>帽子之后就执行了，而并非是在调用的时候。这个从等价形式也可以得出结论，因为带帽的时候其实已经做过某些调用了，这个你可以细品。<br>❞</p>
</blockquote>
<p>重点是闭包<code>wrapper</code>内部的代码的执行顺序。通过等价公式不难得出，最后执行的<code>func</code>已经不是原来的<code>func</code>函数，而是<code>decorator_outer(func)</code>。</p>
<ul>
<li>所以执行<code>func()</code>其实是执行了<code>decorator_outer(func)()</code>，因此先打印了<code>外层装饰器，函数运行之前</code>;</li>
<li>然后执行<code>decorator_outer</code>装饰器<code>wrapper</code>闭包里的<code>func</code>函数，而<code>decorator_outer</code>装饰器<code>wrapper</code>闭包里的<code>func</code>函数此时是<code>func = decorator_inner(func)</code>;</li>
<li>所以紧接着打印了<code>内层装饰器，函数运行之前</code>—&gt;<code>我是函数本身</code>—&gt;<code>内层装饰器，函数运行之后</code>—&gt;<code>外层装饰器，函数运行之后</code>。</li>
</ul>
<blockquote>
<p>❝ 所以，当我们说多个装饰器堆叠的时候，哪个装饰器的代码先运行时，不能一概而论说内层装饰器的代码先运行。<br>❞</p>
</blockquote>
<p>闭包<code>wrapper</code>内部的代码执行逻辑：</p>
<ol>
<li>外层装饰器先执行，但只执行了一部分，执行到调用<code>func()</code></li>
<li>内层装饰器开始执行</li>
<li>内层装饰器执行完</li>
<li>外层装饰器执行完</li>
</ol>
<blockquote>
<p>❝ 重点：需要搞清楚<code>函数和函数调用</code>的区别，注意：函数是可以当成返回值的<br>❞</p>
</blockquote>
<p>在实际应用的场景中，当我们采用上面的方式写了两个装饰方法比如先验证有没有登录<code>@login_required</code>，再验证权限够不够时<code>@permision_allowed</code>时，我们采用下面的顺序来装饰函数:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def login_required(func):</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        print(&#x27;检测是否有特定的Cookies&#x27;)</span><br><span class="line">        is_login = False</span><br><span class="line">        if not is_login:</span><br><span class="line">            return &#123;&#x27;success&#x27;: False, &quot;msg&quot;: &quot;没有登录&quot;&#125;</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def permision_allowed(func):</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        print(&#x27;检测是否有特定的数据集权限&#x27;)</span><br><span class="line">        print(&#x27;首先从请求参数中获取dataset_id&#x27;)</span><br><span class="line">        print(&#x27;然后从登录session中获取用户id，注意，如果没有登录，是没有session的&#x27;)</span><br><span class="line">        print(&#x27;判断用户是否有这个dataset的权限&#x27;)</span><br><span class="line">        has_data_set_permission = True</span><br><span class="line">        if not has_data_set_permission:</span><br><span class="line">            return &#123;&#x27;success&#x27;: False, &quot;msg&quot;: &quot;没有数据集权限&quot;&#125;</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@login_required</span><br><span class="line">@permision_allowed</span><br><span class="line">def f()</span><br><span class="line">  # Do something</span><br><span class="line">  return</span><br></pre></td></tr></table></figure>

<h2 id="装饰器应用场景示例"><a href="#装饰器应用场景示例" class="headerlink" title="装饰器应用场景示例"></a><strong>装饰器应用场景示例</strong></h2><h3 id="缓存装饰器"><a href="#缓存装饰器" class="headerlink" title="缓存装饰器"></a><strong>缓存装饰器</strong></h3><p>下面的缓存装饰器可以帮助你避免重复计算，以提高代码的性能。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">def cache_decorator(func):</span><br><span class="line">    # 创建一个字典来存储缓存的结果</span><br><span class="line">    cache = dict()</span><br><span class="line"></span><br><span class="line">    # 定义内部包装函数，用于接收任意数量的位置参数</span><br><span class="line"></span><br><span class="line">    def wrapper(*args):</span><br><span class="line">        # 检查当前参数是否在缓存中</span><br><span class="line">        if args in cache:</span><br><span class="line">            # 如果在缓存中，则从缓存中获取结果并打印提示信息</span><br><span class="line">            print(f&quot;从缓存中获取&#123;args&#125;的结果&quot;)</span><br><span class="line">            return cache[args]</span><br><span class="line">        # 如果不在缓存中，则调用原始函数计算结果</span><br><span class="line">        result = func(*args)</span><br><span class="line">        # 将计算结果存储到缓存中，并打印提示信息</span><br><span class="line">        cache[args] = result</span><br><span class="line">        print(f&quot;计算&#123;args&#125;的结果并将其存入缓存&quot;)</span><br><span class="line">        # 返回计算结果</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    # 返回包装函数</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用缓存装饰器修饰fibonacci函数</span><br><span class="line">@cache_decorator</span><br><span class="line">def fibonacci(n):</span><br><span class="line">    if n &lt; 2:</span><br><span class="line">        return n</span><br><span class="line">    else:</span><br><span class="line">        return fibonacci(n - 1) + fibonacci(n - 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(fibonacci(3))</span><br><span class="line">print(&quot;*****************&quot;)</span><br><span class="line">print(fibonacci(10))</span><br></pre></td></tr></table></figure>

<h3 id="输入合法性检查"><a href="#输入合法性检查" class="headerlink" title="输入合法性检查"></a><strong>输入合法性检查</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 定义类型检查装饰器</span><br><span class="line">def type_check_decorator(func):</span><br><span class="line">    # 定义内部包装函数，用于接收任意数量的位置参数和关键字参数</span><br><span class="line"></span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        # 遍历位置参数</span><br><span class="line">        for i, arg in enumerate(args):</span><br><span class="line">            # 如果参数不是字符串类型，抛出TypeError异常</span><br><span class="line">            if not isinstance(arg, str):</span><br><span class="line">                raise TypeError(f&quot;第&#123;i + 1&#125;个参数值&#123;arg&#125;必须是str类型&quot;)</span><br><span class="line">        # 遍历关键字参数</span><br><span class="line">        for key, value in kwargs.items():</span><br><span class="line">            # 如果关键字参数的值不是字符串类型，抛出TypeError异常</span><br><span class="line">            if not isinstance(value, str):</span><br><span class="line">                raise TypeError(f&quot;关键字参数&#123;key&#125;必须是str类型&quot;)</span><br><span class="line">        # 参数检查通过后，调用原始函数并返回结果</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    # 返回包装函数</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用类型检查装饰器修饰concat_strings函数</span><br><span class="line">@type_check_decorator</span><br><span class="line">def concat_strings(*strings, sep=&quot;-&quot;):</span><br><span class="line">    return sep.join(strings)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(concat_strings(&quot;1&quot;, 3, &quot;5&quot;, sep=&quot;&quot;))</span><br></pre></td></tr></table></figure>

<h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a><strong>日志记录</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log_execution_time(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        start = time.perf_counter()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        end = time.perf_counter()</span><br><span class="line">        print(&#x27;&#123;&#125; took &#123;&#125; ms&#x27;.format(func.__name__, (end - start) * 1000))</span><br><span class="line">        return res</span><br><span class="line">    return wrapper</span><br><span class="line">    </span><br><span class="line">@log_execution_time</span><br><span class="line">def calculate_similarity(items):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a><strong>身份认证</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def authenticate(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        request = args[0]</span><br><span class="line">        if check_user_logged_in(request): # 如果用户处于登录状态</span><br><span class="line">            return func(*args, **kwargs) # 执行函数post_comment() </span><br><span class="line">        else:</span><br><span class="line">            raise Exception(&#x27;Authentication failed&#x27;)</span><br><span class="line">    return wrapper</span><br><span class="line">    </span><br><span class="line">@authenticate</span><br><span class="line">def post_comment(request, ...)</span><br><span class="line">    ...</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def singleton(cls):</span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        if cls not in instances:</span><br><span class="line">            instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        return instances[cls]</span><br><span class="line">    </span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class Logger:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.log_file = open(&quot;log.txt&quot;, &quot;a&quot;)</span><br><span class="line"></span><br><span class="line">    def log(self, message):</span><br><span class="line">        self.log_file.write(f&quot;&#123;message&#125;\n&quot;)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>singleton</code> 装饰器用于创建单例类。装饰器包装了 <code>Logger</code> 类，确保只有一个 <code>Logger</code> 的实例存在。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><strong>策略模式</strong></h3><p>电商领域有个功能明显可以使用“策略”模式，即根据客户的属性或订单中的商品计算折扣。<br>假如一个网店制定了下述折扣规则。</p>
<ul>
<li>有<code>1000或以上积分</code>的顾客，每个订单享<code>5%</code> 折扣。</li>
<li>同一订单中，单个商品的数量达到<code>20个或以上</code>，享<code>10%</code>折扣。</li>
<li>订单中的不同商品达到<code>10个或以上</code>，享<code>7%</code>折扣。</li>
</ul>
<p>简单起见，我们<code>假定一个订单一次只能享用一个折扣</code>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">from collections import namedtuple</span><br><span class="line"></span><br><span class="line">promos = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def promotion(promo_func):</span><br><span class="line">    promos.append(promo_func)</span><br><span class="line">    return promo_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@promotion</span><br><span class="line">def fidelity(order):</span><br><span class="line">    &quot;&quot;&quot;为积分为1000或以上的顾客提供5%折扣&quot;&quot;&quot;</span><br><span class="line">    return order.total() * .05 if order.customer.fidelity &gt;= 1000 else 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@promotion</span><br><span class="line">def bulk_item(order):</span><br><span class="line">    &quot;&quot;&quot;单个商品为20个或以上时提供10%折扣&quot;&quot;&quot;</span><br><span class="line">    discount = 0</span><br><span class="line">    for item in order.cart:</span><br><span class="line">        if item.quantity &gt;= 20:</span><br><span class="line">            discount += item.total() * .1</span><br><span class="line">    return discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@promotion</span><br><span class="line">def large_order(order):</span><br><span class="line">    &quot;&quot;&quot;订单中的不同商品达到10个或以上时提供7%折扣&quot;&quot;&quot;</span><br><span class="line">    distinct_items = &#123;item.product for item in order.cart&#125;</span><br><span class="line">    if len(distinct_items) &gt;= 10:</span><br><span class="line">        return order.total() * .07</span><br><span class="line">    return 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def best_promo(order):</span><br><span class="line">    &quot;&quot;&quot;选择可用的最佳折扣&quot;&quot;&quot;</span><br><span class="line">    return max(promo(order) for promo in promos)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Customer = namedtuple(&#x27;Customer&#x27;, &#x27;name fidelity&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LineItem:</span><br><span class="line">    def __init__(self, product, quantity, price):</span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    def total(self):</span><br><span class="line">        return self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Order:  # 上下文</span><br><span class="line">    def __init__(self, customer, cart, promotions=None):</span><br><span class="line">        self.__total = None</span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotions</span><br><span class="line"></span><br><span class="line">    def total(self):</span><br><span class="line">        if not hasattr(self, &#x27;__total&#x27;):</span><br><span class="line">            self.__total = sum(item.total() for item in self.cart)</span><br><span class="line">        return self.__total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">joe = Customer(&#x27;John Doe&#x27;, 1000)</span><br><span class="line"></span><br><span class="line">joe_cart = [LineItem(&#x27;banana&#x27;, 4, 5.0), LineItem(&#x27;apple&#x27;, 10, 1.5), LineItem(&#x27;watermellon&#x27;, 5, 5.0)]</span><br><span class="line"></span><br><span class="line">joe_order = Order(joe, joe_cart)</span><br><span class="line"></span><br><span class="line">print(best_promo(joe_order))</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>所谓的装饰器，其实就是通过装饰器函数，来修改原函数的一些功能，使得原函数不需要修改。</p>
<p>一切<code>callable</code>的对象都可以被用来实现装饰器。</p>
<p><code>wrapt</code>模块很有用，用它可以帮助我们用更简单的代码写出复杂装饰器。</p>
<p>装饰器的应用场景其实很常见，我们常见的判断用户是否登录(token校验的判断)、用户是否有访问权限很多都是使用装饰器来判断的，在DRF(django restframework)中的<code>@api_view</code>、<code>@permission_classes</code>。</p>
<p>合理使用装饰器，往往能极大地提高程序的可读性以及运行效率。</p>
<p>每当你对装饰器感到迷茫的时候，可以将装饰器用其等价形式理解。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/12/04/hello-world/" rel="prev" title="Hello World">
                  <i class="fa fa-angle-left"></i> Hello World
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">What</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
